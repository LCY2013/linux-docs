# Linux shell 使用记录文档

[http://billie66.github.io/TLCL/book]()

### date — 显示系统当前时间和日期

### cal — 显示当前月的日历

### df  — 查看磁盘剩余空间的数量

### free — 显示空闲内存的数量

### pwd — 打印出当前工作目录名

### cd — 更改目录

### ls — 列出目录内容

```shell
ls -lt "l" 选项产生长格式输出，"t"选项按文件修改时间的先后来排序
ls -lt --reverse	加上长选项 “–reverse”，则结果会以相反的顺序输出
```

| 选项 | 长选项           | 描述                                                         |
| :--- | :--------------- | :----------------------------------------------------------- |
| -a   | --all            | 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 |
| -d   | --directory      | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 |
| -F   | --classify       | 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 |
| -h   | --human-readable | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 |
| -l   |                  | 以长格式显示结果。                                           |
| -r   | --reverse        | 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 |
| -S   |                  | 命令输出结果按照文件大小来排序。                             |
| -t   |                  | 按照修改时间来排序。                                         |

| 字段             | 含义                                                         |
| :--------------- | :----------------------------------------------------------- |
| -rw-r--r--       | 对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。 |
| 1                | 文件的硬链接数目。参考随后讨论的关于链接的内容。             |
| root             | 文件所有者的用户名。                                         |
| root             | 文件所属用户组的名字。                                       |
| 32059            | 以字节数表示的文件大小。                                     |
| 2007-04-03 11:05 | 上次修改文件的时间和日期。                                   |
| oo-cd-cover.odf  | 文件名。                                                     |



### file — 确定文件类型

```shell
file fileName		eg:	file picture.jpg
```



### less — 浏览文件内容

```markdown
less fileName   eg: less /etc/passwd
```

| 命令               | 行为                                                     |
| :----------------- | :------------------------------------------------------- |
| Page UP or b       | 向上翻滚一页                                             |
| Page Down or space | 向下翻滚一页                                             |
| UP Arrow           | 向上翻滚一行                                             |
| Down Arrow         | 向下翻滚一行                                             |
| G                  | 移动到最后一行                                           |
| 1G or g            | 移动到开头一行                                           |
| /charaters         | 向前查找指定的字符串                                     |
| n                  | 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
| h                  | 显示帮助屏幕                                             |
| q                  | 退出 less 程序                                           |



### more — 浏览文件内容  less is more



### Linux 系统介绍

| 目录           | 评论                                                         |
| :------------- | :----------------------------------------------------------- |
| /              | 根目录，万物起源。                                           |
| /bin           | 包含系统启动和运行所必须的二进制程序。                       |
| /boot          | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 |
| /dev           | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 |
| /etc           | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 |
| /home          | 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib           | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found    | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 |
| /media         | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt           | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。     |
| /opt           | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc          | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root          | root 帐户的家目录。                                          |
| /sbin          | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp           | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 |
| /usr           | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin       | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 |
| /usr/lib       | 包含由/usr/bin 目录中的程序所用的共享库。                    |
| /usr/local     | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin      | 包含许多系统管理程序。                                       |
| /usr/share     | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var           | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 |
| /var/log       | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |



### cp — 复制文件和目录

```shell
cp item1 item2 复制单个文件或目录"item1"到文件或目录"item2"
cp item... directory	复制多个项目（文件或目录）到一个目录下
```

#### cp参数信息

| 选项              | 意义                                                         |
| :---------------- | :----------------------------------------------------------- |
| -a, --archive     | 复制文件和目录，以及它们的属性，包括拥有者和所有权。 通常，副本具有用户所操作文件的默认属性。 |
| -i, --interactive | 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。 |
| -r, --recursive   | 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。 |
| -u, --update      | 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 |
| -v, --verbose     | 显示翔实的命令操作信息                                       |

#### cp示例

|        命令         | 运行结果                                                     |
| :-----------------: | :----------------------------------------------------------- |
|   cp file1 file2    | 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。 |
|  cp -i file1 file2  | 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。 |
| cp file1 file2 dir1 | 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 |
|   cp dir1/* dir2    | 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 |
|   cp -r dir1 dir2   | 复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。 |

### mv — 移动/重命名文件和目录

```shell
mv item1 item2		把文件或目录 "item1" 移动或重命名为 "item2"
mv item...	directory 把一个或多个条目从一个目录移动到另一个目录中
```

#### *mv 选项*

| 选项             | 意义                                                         |
| :--------------- | :----------------------------------------------------------- |
| -i --interactive | 在重写一个已经存在的文件之前，提示用户确认信息。 **如果不指定这个选项，mv 命令会默认重写文件内容。** |
| -u --update      | 当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。 |
| -v --verbose     | 当操作 mv 命令时，显示翔实的操作信息。                       |

#### *mv 实例*

| mv file1 file2      | 移动 file1 到 file2。**如果 file2 存在，它的内容会被 file1 的内容重写。** 如果 file2 不存在，则创建 file2。 **这两种情况下，file1 都不再存在。** |
| ------------------- | ------------------------------------------------------------ |
| mv -i file1 file2   | 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。 |
| mv file1 file2 dir1 | 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。      |
| mv dir1 dir2        | 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。 |

### mkdir — 创建目录

```shell
mkdir directory...	eg:  mkdir dir1 dir2 dir3
tips:在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复 
```



### rm — 删除文件和目录

```shell
rm item...	"item"代表一个或多个文件或目录
```

#### rm 选项

| -i, --interactive | 在删除已存在的文件前，提示用户确认信息。 **如果不指定这个选项，rm 会默默地删除文件** |
| ----------------- | ------------------------------------------------------------ |
| -r, --recursive   | 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 |
| -f, --force       | 忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。 |
| -v, --verbose     | 在执行 rm 命令时，显示翔实的操作信息。                       |

#### *rm 实例*

| 命令              | 运行结果                                                     |
| :---------------- | :----------------------------------------------------------- |
| rm file1          | 默默地删除文件                                               |
| rm -i file1       | 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。 |
| rm -r file1 dir1  | 删除文件 file1, 目录 dir1，及 dir1 中的内容。                |
| rm -rf file1 dir1 | 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。 |



### ln — 创建硬链接和符号链接

```shell
ln file link	创建硬链接
ln -s file link		创建符号链接，"item" 可以是一个文件或是一个目录
```





### *文件系统通用匹配符*

| 通配符        |                意义                |
| :------------ | :--------------------------------: |
| *             | 匹配任意多个字符（包括零个或一个） |
| ?             |   匹配任意一个字符（不包括零个）   |
| [characters]  |   匹配任意一个属于字符集中的字符   |
| [!characters] |   匹配任意一个不是字符集中的字符   |
| [[:class:]]   | 匹配任意一个属于指定字符类中的字符 |

### *普遍使用的字符类*

| 字符类    | 意义                   |
| :-------- | :--------------------- |
| [:alnum:] | 匹配任意一个字母或数字 |
| [:alpha:] | 匹配任意一个字母       |
| [:digit:] | 匹配任意一个数字       |
| [:lower:] | 匹配任意一个小写字母   |
| [:upper:] | 匹配任意一个大写字母   |

### *通配符范例*

| 模式                   | 匹配对象                                                  |
| :--------------------- | :-------------------------------------------------------- |
| *                      | 所有文件                                                  |
| g*                     | 文件名以“g”开头的文件                                     |
| b*.txt                 | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件 |
| Data???                | 以“Data”开头，其后紧接着3个字符的文件                     |
| [abc]*                 | 文件名以"a","b",或"c"开头的文件                           |
| BACKUP.[0-9][0-9][0-9] | 以"BACKUP."开头，并紧接着3个数字的文件                    |
| [[:upper:]]*           | 以大写字母开头的文件                                      |
| [![:digit:]]*          | 不以数字开头的文件                                        |
| *[[:lower:]123]        | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件    |



### 使用命令

```markdown
type – 说明怎样解释一个命令名
	type command	type 命令是 shell 内部命令，它会显示命令的类别
which – 显示会执行哪个可执行程序
	which go 
help － 得到 shell 内建命令的帮助文档	
	help cd
	mkdir --help
man – 显示命令手册页
	man program
	手册页的组织形式
	章节	内容
  1			用户命令
  2			程序接口内核系统调用
  3			C 库函数程序接口
  4			特殊文件，比如说设备结点和驱动程序
  5			文件格式
  6			游戏娱乐，如屏幕保护程序
  7			其他方面
  8			系统管理员命令
  man section search_term 
  eg: man 5 /etc/passwd 命令运行结果会显示文件 /etc/passwd 的文件格式说明手册
apropos – 显示一系列适合的命令
	apropos floppy	输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man 命令加上”-k”选项， 和 apropos 完成一样的功能。
info – 显示命令 info
	info coreutils
	命令												行为
  ?												显示命令帮助
  PgUp or Backspace				显示上一页
  PgDn or Space						显示下一页
  n										下一个 - 显示下一个结点
  p										上一个 - 显示上一个结点
  u									Up - 显示当前所显示结点的父结点，通常是个菜单
  Enter								激活光标位置下的超级链接
  q													退出
whatis – 显示一个命令的简洁描述
alias – 创建命令别名
	alias foo='cd /usr; ls; cd -'
	alias name='string'
	unalias foo
```



### 重定向

```markdown
我们使用 “>” 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件
ls -l /usr/bin > ls-output.txt

怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用”>>“重定向符
ls -l /usr/bin >> ls-output.txt

文件流的前三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：
ls -l /bin/usr 2> ls-error.txt 文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务

必须同时重定向标准输出和标准错误
ls -l /bin/usr > ls-output.txt 2>&1
首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1


cat － 连接文件
cat movie.mpeg.0* > movie.mpeg 可以链接多个有序的文件合成一个文件
cat 等待标准输入
cat > magic.txt 可以输入一些标准输入到magic.txt文件中
cat "fufeng" > magic.txt 将fufeng这个标准输入输出到magic.txt中
cat magic.txt 将magic.txt的标准输入文件输出到屏幕
cat < magic.txt 可以将标准键盘事件用magic.txt替换成输入源

| 管道线
command1 | command2
ls -l /usr/bin | less   将ls -l 的结果集作为less的接受信息
ls -l /usr/bin | sort | less 过滤器
ls -l /usr/bin | sort | uniq | less uniq 从标准输入或单个文件名参数接受数据有序 列表（详情查看 uniq 手册页），默认情况下，从数据列表中删除任何重复行
ls -l /usr/bin | sort | uniq -d | less uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复的数据列表，让 uniq 命令带上”-d”选项

sort － 排序文本行

uniq － 报道或省略重复行

grep － 打印匹配行
grep pattern [file...]
ls /bin /usr/bin | sort | uniq | grep  zip 程序列表中，找到文件名中包含单词”zip”的所有文件


wc － 打印文件中换行符，字，和字节个数
wc magic.txt  
ls /bin /usr/bin | sort | uniq | wc -l  如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能 报道行数
”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行

head － 输出文件第一部分
head -n 5 magic.txt  输出magic.txt 的前五行数据
ls /usr/bin | head -n 5 展示/usr/bin 下面查询到的前5行数据

tail - 输出文件最后一部分
tail -n 5 magic.txt 输出结尾的5行数据
tail -f /var/log/monthly.out tail  有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入

tee - 从标准输入读取数据，并同时写到标准输出和文件
ls /usr/bin | tee tee.txt | grep zip tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件

```

### [从 shell 眼中看世界](http://billie66.github.io/TLCL/book/chap08.html)

```shell
echo － 显示一行文本
echo hello,fufeng   打印hello,fufeng
echo * 当前目录的所有文件和目录信息,这里的*就是通配符
echo E* 打印E开头的路径下目录文件展开的信息
echo *E 打印E结尾的路径下目录文件展开的信息
echo [[:upper:]]* 打印大写字母开头的所有路径展开信息
echo /usr/*/share  查看家目录之外的目录
echo .*  显示.开头的隐藏文件
echo ~
echo ~LuoCY
echo $((2*3)) 算术表达式$((expression))
echo $(($((5**2))*3))  5平方乘以3
echo Five Divided Two Equals $((5/2)) 
echo Before-{1,2,3}-After 花括号展开Before-1-After Before-2-After Before-3-After 
echo {Z..A}  从Z 按递减顺序打印到A
echo b{A{1,2},B{1,2}}a   bA1a bA2a bB1a bB2a
mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
rm -rf {2007..2009}-0{1..9}
echo $USER  输出当前用户
printenv | less		less查看当前环境信息
echo $(ls)  命令替换允许我们把一个命令的输出作为一个展开模式来使用
echo this is     test   this is test  多余空格被删除
echo this is $100.00  this is .00   $1替换成了空字符串
echo "$USER $((3*7)) $(cal)"   用户名称 计算结果 日历原样展示
单双引号、无引号作用
echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
-> text err.txt magic.txt tee.txt a b foo 4 LuoCY
echo "text *.txt {a,b} $(echo foo) $((2+2)) $USER"
-> text *.txt {a,b} foo 4 LuoCY
echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
-> text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
转义字符通过\来防止转义
echo "The balance for user $USER is: \$5.00" 
-> The balance for user LuoCY is: $5.00
转义序列	含义
\a			响铃（”警告”－导致计算机嘟嘟响）
\b			退格符
\n			新的一行。在类 Unix 系统中，产生换行。
\r			回车符
\t			制表符
echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $' ' 里面。 以下例子中，我们可以使用 sleep 命令创建一个简单的倒数计数器（ sleep 是一个简单的程序， 它会等待指定的秒数，然后退出）：
sleep 10; echo -e "Time's up\a"
我们也可以这样做：
sleep 10; echo "Time's up" $'\a'

ls -l | $(which cp)  相当于执行 which cp
ls -l $(which cp)  查看cp命令位置详细信息
ls -l `which cp`  查看cp命令位置详细信息
file $(ls /usr/bin/* | grep zip)   管道线的输出结果成为 file 命令的参数列表
ls -d .* | less  为了在这种情况下正确地完成路径名展开，我们应该使用一个更精确的模式
ls -d .[!.]?*  这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单
ls -a
ls -A
ls -l "two words.txt"   使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名
```

### 键盘高级操作技巧

```shell
clear － 清空屏幕 等价于 Ctrl-l
history － 显示历史命令列表内容
	history | less   查看.bash_history文件中的信息
	histroy | grep /usr/bin   查看利用了/usr/bin下面的命令的历史记录
	 2058  ls -l /usr/bin > ls-output.txt
   2060  ls -l /usr/bin > ls-output.txt
   2064  ls -l /usr/bin > ls-output.txt
   2066  ls -l /usr/bin >> ls-output.txt
   2146  ls -l /usr/bin | sort | less
  通过上面的命令得到了下面带行号的命令列表，可以试试下面的命令
  $ !2058   数字 “2058” 是这个命令在历史列表中的行号,bash 会把 “!2058” 展开成为历史列表中2058行的内容
  输入 Ctrl-r来启动增量搜索， 接着输入你要寻找的字。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个 匹配项（历史列表中向上移动）。输入 Ctrl-g 或者 Ctrl-c，退出搜索
历史命令
按键									行为
Ctrl-p			移动到上一个历史条目。类似于上箭头按键。
Ctrl-n			移动到下一个历史条目。类似于下箭头按键。
Alt-<				移动到历史列表开头。
Alt->				移动到历史列表结尾，即当前命令行。
Ctrl-r			反向增量搜索。从当前命令行开始，向上增量搜索。
Alt-p				反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter来执行搜索）。
Alt-n				向前搜索，非增量。
Ctrl-o			执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。  
历史展开命令
序列								行为
!!					重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。
!number			重复历史列表中第 number 行的命令。
!string			重复最近历史列表中，以这个字符串开头的命令。
!?string		重复最近历史列表中，包含这个字符串的命令。

script [file]  开启文件file定义一个脚本文件，该会话中所有的命令都会记录在里面，通过exit退出脚本输出 

光标移动命令
按键							行动
Ctrl-a				移动光标到行首。
Ctrl-e				移动光标到行尾。
Ctrl-f				光标前移一个字符；和右箭头作用一样。
Ctrl-b				光标后移一个字符；和左箭头作用一样。
Alt-f					光标前移一个字。
Alt-b					光标后移一个字。
Ctrl-l				清空屏幕，移动光标到左上角。clear 命令完成同样的工作。

文本编辑命令
按键									行动
Ctrl-d					删除光标位置的字符。
Ctrl-t					光标位置的字符和光标前面的字符互换位置。
Alt-t						光标位置的字和其前面的字互换位置。
Alt-l						把从光标位置到字尾的字符转换成小写字母。
Alt-u						把从光标位置到字尾的字符转换成大写字母。

剪切和粘贴命令
按键								行动
Ctrl-k					剪切从光标位置到行尾的文本。
Ctrl-u					剪切从光标位置到行首的文本。
Alt-d						剪切从光标位置到词尾的文本。
Alt-Backspace		剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
Ctrl-y					把剪切环中的文本粘贴到光标位置。

自动补全 -  tab 键
自动补全命令
按键						行动
Alt-?		显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。
Alt-*		插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。

set | less
查看一下如果你能找到它们的话。默认情况下，并不是所有的发行版都包括它们。
```

### 权限

```shell
权限计算表达: r(4)w(2)x(1)-(0)

id – 显示用户身份号
uid=501(LuoCY) gid=20(staff) groups=20(staff)...
chmod – 更改文件模式  
注意:八进制的权限掩码用三位数字来表示
一是 setuid 位（八进制4000）
二个是 setgid 位（八进制2000）
三个是 sticky 位（八进制1000）
chmod 777 fileName  等价于授于所有人rwx权限
chmod +x execute.sh  授于execute.sh可执行的权限
chmod u+s program  授予一个程序 setuid 权限
一个程序被设置为setuid属性:-rwsr-xr-x
chmod g+s dir		授予一个目录 setgid 权限
setgid属性的目录:drwxrwsr-x
chmod +t dir    授予一个目录 sticky 权限
sticky位的目录:drwxrwxrwt

umask – 设置默认的文件权限
umask 获取当前权限掩码
umask 022(000 010 010) 设置当前的权限掩码为022
-rw-r--r--  1 LuoCY  staff  13  7 17 16:31 err.txt
计算(异或)
原始文件:             (110 110 110)
掩码:		   						(000 010 010)
结果:-rw-r--r--       (110 100 100)

su – 以另一个用户的身份来运行 shell
su root

sudo – 以另一个用户的身份来执行命令
sudo ls -l 

chown － 更改文件所有者和用户组
chown [owner][:[group]] file...
chown -R 用户:用户组 fileName
chown 参数实例
参数								结果
bob						把文件所有者从当前属主更改为用户 bob。
bob:users			把文件所有者改为用户 bob，文件用户组改为用户组 users。
:admins				把文件用户组改为组 admins，文件所有者不变。
bob:					文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。

chgrp – 更改文件组所有权
chgrp -v 组名 fileName

passwd – 更改用户密码
passwd 用户名称

文件类型
属性										文件类型
-										一个普通文件
d											一个目录
l							一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。
c							一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器
b							一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。

权限属性
属性									文件										目录
r							允许打开并读取文件内容。			允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。
w							允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。			允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。
x					允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。														允许进入目录，例如：cd directory 。

权限属性示例
文件属性							含义
-rwx------	一个普通文件，对文件所有者来说可读、可写、可执行。其他人无法访问。
-rw-------	一个普通文件，对文件所有者来说可读可写。其他人无法访问。
-rw-r--r--	一个普通文件，对文件所有者来说可读可写，文件所有者的组成员可以读该文件，其他所有人都可以读该文件。
-rwxr-xr-x	一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。
-rw-rw----	一个普通文件，对文件所有者以及文件所有者的组成员来说可读可写。
lrwxrwxrwx	一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。
drwxrwx---	一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。
drwxr-x---	一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。

chmod 							命令符号表示法
u						"user"的简写，意思是文件或目录的所有者。
g											用户组。
o						"others"的简写，意思是其他所有的人。
a						"all"的简写，是"u", "g"和“o”三者的联合。

chmod 						符号表示法实例
u+x							为文件所有者添加可执行权限。
u-x							删除文件所有者的可执行权限。
+x							为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。
o-rw						除了文件所有者和用户组，删除其他人的读权限和写权限。
go=rw						给文件所属的组和文件所属者/组以外的人读写权限。如果文件所属组或其他人已经拥有执行的权限，执行权限将被移除。
u+x,go=rw				给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。

更改身份
1、注销系统并以其他用户身份重新登录系统。
2、使用 su 命令。
	su － 以其他用户身份和组 ID 运行一个 shell
	su [-[l]] [user] ”-l”选项，那么会为指定用户启动一个需要登录的 shell,意味着会加载此用户的 shell 环境，选项”-l”可以缩写为"-",启动超级用户的 shell su -
	su -c 'command'   eg: su -c 'ls /root/*'
	
3、使用 sudo 命令。
	sudo － 以另一个用户身份执行命令
	sudo command
	eg: sudo backup_script
	sudo 命令可以授予哪些权限，使用”-l”选项，列出所有权限
```



### 进程

```shell
ps – 报告当前进程快照
ps x 获取系统更多的运行状态  使用这个 “x” 选项，可以 看到我们所拥有的每个进程的信息。
ps x | less 管道命令查看

ps aux   BSD 风格
BSD 风格的 ps 命令列标题
标题						含义
USER			用户 ID. 进程的所有者。
%CPU			以百分比表示的 CPU 使用率
%MEM			以百分比表示的内存使用率
VSZ				虚拟内存大小
RSS				进程占用的物理内存的大小，以千字节为单位。
START			进程启动的时间。若它的值超过24小时，则用天表示。
LuoCY 88760 0.0 1.4 89886744 227700 ?? Ss 9:24上午 3:23.13 /System/Library/

进程状态
状态							含义
R					运行中。这意味着，进程正在运行或准备运行。
S					正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。
D					不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。
T					已停止. 已经指示进程停止运行。稍后介绍更多。
Z					一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）
<					一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。
N					低优先级进程。 一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。

top – 显示任务
top 命令信息字段
行号							字段							意义
1								top								程序名。
							14:59:20						当前时间。
							up 6:30							这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。
							2 users							有两个用户登录系统。
						load average:					加载平均值是指，等待运行的进程数目，也就是说，处于可以运行状态并共享 CPU 的进程个数。 这里展示了三个数值，每个数值对应不同的时间段。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。
2						Tasks:							总结了进程数目和这些进程的各种状态。
3						Cpu(s):							这一行描述了 CPU 正在进行的活动的特性。
						0.7%us							0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。
						1.0%sy							1.0%的 CPU 时间被用于系统（内核）进程。
						0.0%ni							0.0%的 CPU 时间被用于"nice"（低优先级）进程。
						98.3%id							98.3%的 CPU 时间是空闲的。
						0.0%wa							0.0%的 CPU 时间来等待 I/O。
4						Mem:								展示物理内存的使用情况。
5						Swap:								展示交换分区（虚拟内存）的使用情况。
top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h，显示程序的帮助屏幕，q， 退出 top 程序。H 表示切换显示进程和线程信息。
xlogo 程序是 X 窗口系统,如果你的系统不包含 xlogo 程序，试着用 gedit 或者 kwrite 来代替。

jobs – 列出活跃的任务

bg – 把一个任务放到后台执行
我们想要停止一个进程，而不是终止它。我们这么做通常是为了允许前台进程被移动到后台。 输入 Ctrl-z，可以停止一个前台进程。
# jobs
[1]+ Stopped                 xlogo
然后可以利用下面的指令将停止的任务移动到后台执行，或者在启动的时候使用& 
# bg %1 
# xlogo &

fg – 把一个任务放到前台执行
# jobs
[1]+ Running        xlogo &
# fg %1 将编号为1的任务放到前台执行

kill – 给一个进程发送信号
kill -INT PID 给进程一个信号值
kill -SIGINT PID
kill PID  这里的进程会有一个回调应用程序的过程，应用程序可以用来做收尾
kill -9 PID 直接杀掉进程
kill -l 查看所有的信号量

killall – 杀死指定名字的进程
killall [-u user] [-signal] name...
killall xlogo   杀掉进程xlogo所有相关的进程

shutdown – 关机或重启系统

其它与进程相关的命令
命令名									命令描述
pstree					输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系。
vmstat					输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上更新操作延时的时间（以秒为单位）。例如，“vmstat 5”。 ，按下 Ctrl-c 组合键, 终止输出。
xload						一个图形界面程序，可以画出系统负载随时间变化的图形。
tload						terminal load与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。
```

### shell 环境

```shell
printenv - 打印部分或所有的环境变量
printenv | less 通过管道命令打印出所有的环境信息
printenv USER  打印出环境变量中的用户等价于 echo $USER

set - 设置 shell 选项
set | less 没有带选项和参数的 set 命令时，shell 变量，环境变量，和定义的 shell 函数 都会被显示,不同于printenv的是set 命令的输出很友好地按照首字母顺序排列

export — 导出环境变量，让随后执行的程序知道。

alias - 创建命令别名
alias 不带参数的 alias 来查看别名

环境变量
变量													内容
DISPLAY					如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 ":0"， 意思是由 X 产生的第一个显示器。
EDITOR					文本编辑器的名字。
SHELL						shell 程序的名字。
HOME						用户家目录。
LANG						定义了字符集以及语言编码方式。
OLD_PWD					先前的工作目录。
PAGER						页输出程序的名字。这经常设置为/usr/bin/less。
PATH						由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。
PS1							Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。
PWD							当前工作目录。
TERM						终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。
TZ							指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。
USER						你的用户名

登录 shell 会话的启动文件
文件												内容
/etc/profile		应用于所有用户的全局配置脚本。
~/.bash_profile	用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。
~/.bash_login		如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。
~/.profile			如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。

非登录 shell 会话的启动文件
文件													内容
/etc/bash.bashrc			应用于所有用户的全局配置文件。
~/.bashrc		用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。

eg:
 foo="hello,i'm fufeng."   创建一个名叫foo的变量
 echo $foo   打印出这个变量
 foo="$foo , welcome to my github." 变量中使用变量
 echo $foo   打印出最新的这个变量

文本行														含义
umask 0002						设置掩码来解决共享目录的问题。
export HISTCONTROL=ignoredups		使得 shell 的历史记录功能忽略一个命令，如果相同的命令已被记录。
export HISTSIZE=1000	增加命令历史的大小，从默认的 500 行扩大到 1000 行。
alias l.='ls -d .* --color=auto'	创建一个新命令，叫做'l.'，这个命令会显示所有以点开头的目录项。
alias ll='ls -l --color=auto'	创建一个叫做'll'的命令，这个命令会显示长格式目录列表。

当我们修改完成后使用source 去激活shell新设置的环境
eg: source .bashrc

```

### vi 简介

```shell
# vi 模式编辑器
进入vi编辑器的输入框, esc -> : -> q 退出vi编辑器
按esc 连续两次回到普通模式
命令模式被叫做普通模式，ex 命令 叫做命令模式
i : 插入模式
w : 保存  :w otherFile.txt 相当于保存一个副本
q : 退出
u : 撤销上一次编辑
a : 光标就会越过行尾，同时 vi 会进入插入模式。
A : 光标将移动到行尾，同时 vi 进入输入模式。
esc : 退出编辑模式，进入普通模式(命令行模式)
o : 当前行的下方打开一行。
O : 当前行的上方打开一行。
x : 删除光标位置的一个字符。
p : 复制剪切的内容到下一行
P : 复制剪切的内容到上一行
J : 用来删除分行符，链接行
j : 用来下移光标
ZZ : 保存并且退出当前文件
f : f 命令能搜索一特定行，并将光标移动到下一个匹配的字符上,命令 fa 会把光标定位到同一行中 下一个出现的”a”字符上。在进行了一次行内搜索后，输入分号能重复这次搜索。
/ :  / 命令，接下来，输入要查找的单词或短语， 按下回车。光标就会移动到下一个包含所查找字符串的位置。通过 n 命令来重复先前的查找。
全局替换查找 : 
	%s/keyWord/replaceKeyWord/g 
	%s/keyWord/replaceKeyWord/gc  c字符代表需要用户确认,接下来就会有一个replace with keyWord (y/n/a/q/l/^E/^Y)?
	y			执行替换操作
  n			跳过这个匹配的实例
  a			对这个及随后所有匹配的字符串执行替换操作。
  q or esc	退出替换操作。
  l			执行这次替换并退出。l 是 “last” 的简写。
  Ctrl-e, Ctrl-y	分别是向下滚动和向上滚动。用于查看建议替换的上下文。

每次我们使用 d 命令，删除的部分被复制到一个 粘贴缓冲区中（看作剪切板）。过后我们执行小 p 命令把剪切板中的文本粘贴到光标位置之后， 或者是大 P 命令把文本粘贴到光标之前。y 命令用来“拉”（复制）文本，和 d 命令剪切文本的方式差不多。这里有些把 y 命令和各种移动命令 结合起来使用的实例

eg: 
vim notFound.txt 这里也是创建一个notFound.txt的文件,需要在结束时:wq
ls -l /usr/bin > ls-output.txt 创建一个叫ls-output.txt的文件

vim notFound.txt ls-output.txt 
:n 切换到下一个文件
:N 切换到上一个文件
:buffers 屏幕中就会显示出一个文件列表
:buffers                                                      
  1 %a   "ls-output.txt"                第 1 行
  2 #    "notFound.txt"                 第 12 行
:buffer number  buffer, 紧跟着你想要编辑的缓冲器编号  
:buffer 2 这里就会去编辑notFound.txt文件
退出多文本编辑
vim notFound.txt 
:e ls-output.txt   e命令加载,这里就不能够使用n或者N切换使用那个编辑的文件，加入ls-output.txt文件输入
:buffers
:buffers
  1 #    "notFound.txt"                 第 12 行
  2 %a   "ls-output.txt"                第 1 行
跨文本复制
:buffer 1  先切换到第一个文本中
在第一个编辑文本中: 
	光标定位某一行,yy 复制这一行
:buffer 2 切换到第二个文本中
 在第二个编辑文本中:
 	光标定位某一行,p(将复制的内容剪切到当前光标所在行的下一行中),P(将复制	的内容剪切到光标所在行的上一行中)
 插入整个文本到另一个文本中
 vim ls-output.txt
 :r notFound.txt   
 r 命令（是”read”的简称）把指定的文件插入到光标位置之前。


```

| 按键                | 移动光标                                          |
| :------------------ | :------------------------------------------------ |
| l or 右箭头         | 向右移动一个字符                                  |
| h or 左箭头         | 向左移动一个字符                                  |
| j or 下箭头         | 向下移动一行                                      |
| k or 上箭头         | 向上移动一行                                      |
| 0 (零按键)          | 移动到当前行的行首。                              |
| ^                   | 移动到当前行的第一个非空字符。                    |
| $                   | 移动到当前行的末尾。                              |
| w                   | 移动到下一个单词或标点符号的开头。                |
| W                   | 移动到下一个单词的开头，忽略标点符号。            |
| b                   | 移动到上一个单词或标点符号的开头。                |
| B                   | 移动到上一个单词的开头，忽略标点符号。            |
| Ctrl-f or Page Down | 向下翻一页                                        |
| Ctrl-b or Page Up   | 向上翻一页                                        |
| numberG             | 移动到第 number 行。例如，1G 移动到文件的第一行。 |
| G                   | 移动到文件末尾。                                  |
| numberj             | 下移动 number 行。例如，1j 向下移动一行。         |

| 命令 | 删除的文本                               |
| :--- | :--------------------------------------- |
| x    | 当前字符                                 |
| 3x   | 当前字符及其后的两个字符。               |
| dd   | 当前行。                                 |
| 5dd  | 当前行及随后的四行文本。                 |
| dW   | 从光标位置开始到下一个单词的开头。       |
| d$   | 从光标位置开始到当前行的行尾。           |
| d0   | 从光标位置开始到当前行的行首。           |
| d^   | 从光标位置开始到文本行的第一个非空字符。 |
| dG   | 从当前行到文件的末尾。                   |
| d20G | 从当前行到文件的第20行。                 |

| 命令 | 复制的内容                               |
| :--- | :--------------------------------------- |
| yy   | 当前行。                                 |
| 5yy  | 当前行及随后的四行文本。                 |
| yW   | 从当前光标位置到下一个单词的开头。       |
| y$   | 从当前光标位置到当前行的末尾。           |
| y0   | 从当前光标位置到行首。                   |
| y^   | 从当前光标位置到文本行的第一个非空字符。 |
| yG   | 从当前行到文件末尾。                     |
| y20G | 从当前行到文件的第20行。                 |

| 条目                    | 含义                                                         |
| :---------------------- | :----------------------------------------------------------- |
| :                       | 冒号字符运行一个 ex 命令。                                   |
| %                       | 指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有5行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。” 如果省略了文本行的范围，那么操作只对当前行生效。 |
| s                       | 指定操作。在这种情况下是，替换（查找与替代）。               |
| /keyWord/replaceKeyWord | 查找类型与替代文本。                                         |
| g                       | 这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。 |

### 自制shell提示符

```shell
提示符是由一个环境变量定义的，叫做 PS1（是“prompt string one” 的简写）。
通过echo 查看PS1内容: echo $PS1
[root@localhost vi]# echo $PS1
[\u@\h \W]\$

eg:
# ps1_old="$PS1"
# echo $ps1_old
# PS1="$ps1_old"
# PS1=
# PS1="\$ "
# PS1="\a\$ " 每次都能听见一声嗡嗡
# PS1="\A \h \$ "  00:04 localhost $
# PS1='\[\033[0;31m\]<\u@\h \W>\$' 显示红色的提示符
# PS1='\[\033[0;31m\]<\u@\h \W>\$\[\033[0m\]' 告诉终端回到原来颜色
# PS1='\[\033[0;41m\]<\u@\h \W>\$\[\033[0m\] ' 红色终端
# PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '  带时钟的终端
```

| 序列 | 显示值                                                       |
| :--- | :----------------------------------------------------------- |
| \a   | 以 ASCII 格式编码的铃声 . 当遇到这个转义序列时，计算机会发出嗡嗡的响声。 |
| \d   | 以日，月，天格式来表示当前日期。例如，“Mon May 26.”          |
| \h   | 本地机的主机名，但不带末尾的域名。                           |
| \H   | 完整的主机名。                                               |
| \j   | 运行在当前 shell 会话中的工作数。                            |
| \l   | 当前终端设备名。                                             |
| \n   | 一个换行符。                                                 |
| \r   | 一个回车符。                                                 |
| \s   | shell 程序名。                                               |
| \t   | 以24小时制，hours:minutes:seconds 的格式表示当前时间.        |
| \T   | 以12小时制表示当前时间。                                     |
| \@   | 以12小时制，AM/PM 格式来表示当前时间。                       |
| \A   | 以24小时制，hours:minutes 格式表示当前时间。                 |
| \u   | 当前用户名。                                                 |
| \v   | shell 程序的版本号。                                         |
| \V   | Version and release numbers of the shell.                    |
| \w   | 当前工作目录名。                                             |
| \W   | 当前工作目录名的最后部分。                                   |
| \!   | 当前命令的历史号。                                           |
| \#   | 当前 shell 会话中的命令数。                                  |
| \$   | 这会显示一个"$"字符，除非你拥有超级用户权限。在那种情况下， 它会显示一个"#"字符。 |
| \[   | 标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印 的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或者是更改文本颜色。 |
| \]   | 标志着非打印字符序列结束。                                   |

| 序列       | 文本颜色 | 序列       | 文本颜色 |
| :--------- | :------- | :--------- | :------- |
| \033[0;30m | 黑色     | \033[1;30m | 深灰色   |
| \033[0;31m | 红色     | \033[1;31m | 浅红色   |
| \033[0;32m | 绿色     | \033[1;32m | 浅绿色   |
| \033[0;33m | 棕色     | \033[1;33m | 黄色     |
| \033[0;34m | 蓝色     | \033[1;34m | 浅蓝色   |
| \033[0;35m | 粉红     | \033[1;35m | 浅粉色   |
| \033[0;36m | 青色     | \033[1;36m | 浅青色   |
| \033[0;37m | 浅灰色   | \033[1;37m | 白色     |

用转义序列来设置背景颜色

\033[0;40m	蓝色	\033[1;44m	黑色	\033[0;41m	红色	

\033[1;45m	紫色	\033[0;42m	绿色	\033[1;46m	青色

\033[0;43m	棕色	\033[1;47m	浅灰色

| 转义编码  | 行动                                           |
| :-------- | :--------------------------------------------- |
| \033[l;cH | 把光标移到第 l 行，第 c 列。                   |
| \033[nA   | 把光标向上移动 n 行。                          |
| \033[nB   | 把光标向下移动 n 行。                          |
| \033[nC   | 把光标向前移动 n 个字符。                      |
| \033[nD   | 把光标向后移动 n 个字符。                      |
| \033[2J   | 清空屏幕，把光标移到左上角（第零行，第零列）。 |
| \033[K    | 清空从光标位置到当前行末的内容。               |
| \033[s    | 存储当前光标位置。                             |
| \033[u    | 唤醒之前存储的光标位置。                       |

| 序列         | 行动                                                         |
| :----------- | :----------------------------------------------------------- |
| \[           | 开始一个非打印字符序列。其真正的目的是为了让 bash 能够正确地计算提示符的大小。如果没有这个转义字符的话，命令行编辑 功能会弄错光标的位置。 |
| \033[s       | 存储光标位置。这个用来使光标能回到原来提示符的位置， 当长条和时钟显示到屏幕上方之后。当心一些 终端仿真器不推崇这个编码。 |
| \033[0;0H    | 把光标移到屏幕左上角，也就是第零行，第零列的位置。           |
| \033[0;41m   | 把背景设置为红色。                                           |
| \033[K       | 清空从当前光标位置到行末的内容。因为现在 背景颜色是红色，则被清空行背景成为红色，以此来创建长条。注意虽然一直清空到行末， 但是不改变光标位置，它仍然在屏幕左上角。 |
| \033[1;33m   | 把文本颜色设为黄色。                                         |
| \t           | 显示当前时间。虽然这是一个可“打印”的元素，但我们仍把它包含在提示符的非打印部分， 因为我们不想 bash 在计算可见提示符的真正大小时包括这个时钟在内。 |
| \033[0m      | 关闭颜色设置。这对文本和背景都起作用。                       |
| \033[u       | 恢复到之前保存过的光标位置处。                               |
| \]           | 结束非打印字符序列。                                         |
| <\u@\h \W>\$ | 提示符字符串。                                               |

### 软件包管理

```markdown
通过yum资源库搜索emacs: yum search emacs
通过apt资源库安装emacs: apt-get update; apt-get install emacs
通过rpm包安装emacs: rpm -i emacs-22.1-7.fc7-i386.rpm
通过apt删除emacs: apt-get remove emacs
通过apt更新: apt-get update或者apt-get upgrade
通过rpm包升级应用: rpm -U emacs-22.1-7.fc7-i386.rpm
列出所安装的软件包命令:
风格           命令
Debian     dpkg --list
Red Hat    rpm -qa
查看软件包信息命令:
风格								命令
Debian					apt-cache show package_name
Red Hat					yum info package_name
查看那个软件包安装了/usr/bin/vim: rpm -qf /usr/bin/vim
```

| 包管理系统           | 发行版 (部分列表)                                            |
| :------------------- | :----------------------------------------------------------- |
| Debian Style (.deb)  | Debian, Ubuntu, Xandros, Linspire                            |
| Red Hat Style (.rpm) | Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS |

| 发行版                                   | 底层工具 | 上层工具          |
| :--------------------------------------- | :------- | :---------------- |
| Debian-Style                             | dpkg     | apt-get, aptitude |
| Fedora, Red Hat Enterprise Linux, CentOS | rpm      | yum               |

| 风格    | 命令                                           |
| :------ | :--------------------------------------------- |
| Debian  | apt-get update; apt-cache search search_string |
| Red Hat | yum search search_string                       |

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | dpkg --install package_file |
| Red Hat | rpm -i package_file         |

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | apt-get remove package_name |
| Red Hat | yum erase package_name      |

| 风格    | 命令                            |
| :------ | :------------------------------ |
| Debian  | apt-get update; apt-get upgrade |
| Red Hat | yum update                      |

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | dpkg --install package_file |
| Red Hat | rpm -U package_file         |

| 风格    | 命令                       |
| :------ | :------------------------- |
| Debian  | dpkg --status package_name |
| Red Hat | rpm -q package_name        |

| 风格    | 命令                    |
| :------ | :---------------------- |
| Debian  | dpkg --search file_name |
| Red Hat | rpm -qf file_name       |

### 存储媒介

```shell
mount – 挂载一个文件系统
umount – 卸载一个文件系统
fsck – 检查和修复一个文件系统
fdisk – 分区表控制器
mkfs – 创建文件系统
fdformat – 格式化一张软盘
dd — 把面向块的数据直接写入设备
genisoimage (mkisofs) – 创建一个 ISO 9660的映像文件
wodim (cdrecord) – 把数据写入光存储媒介
md5sum – 计算 MD5检验码

eg:
# mount  查看所有的挂在点情况
/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
....
/dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,nodev,uid=500)
# umount /dev/hdc  卸载掉自己挂载的软盘
# mkdir /mnt/cdrom  新建一个软盘挂载目录
# mount -t iso9660 /dev/hdc /mnt/cdrom 将软盘内容挂载到自定义目录
# cd /mnt/cdrom 进入挂载点
# ls -l 查看挂载点所有的信息
# unmount /dev/hdc 试图卸载挂载点，失败(因为目前所在的目录是挂载点目录，需要先退出挂载点)
# cd 进入当前用户的目录
# unmount /dev/hdc  这时在卸载挂载点
# ls /dev 查看系统命名的设备
# tail -f /var/log/messages 查看系统日志
```

| 字段 | 内容                           | 说明                                                         |
| :--- | :----------------------------- | :----------------------------------------------------------- |
| 1    | 设备名(Device)                 | 传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说/dev/hda1（第一个 IDE 通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像 USB 驱动设备），许多 现代的 Linux 发行版用一个文本标签和设备相关联。当这个设备连接到系统中时， 这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。 那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。 |
| 2    | 挂载点(Mount point)            | 设备所连接到的文件系统树的目录。                             |
| 3    | 文件系统类型(File System Type) | Linux 允许挂载许多文件系统类型。大多数本地的 Linux 文件系统是 ext3， 但是也支持很多其它的，比方说 FAT16 (msdos), FAT32 (vfat)，NTFS (ntfs)，CD-ROM (iso9660)，等等。 |
| 4    | 选项(Options)                  | 文件系统可以通过各种各样的选项来挂载。有可能，例如，挂载只读的文件系统， 或者挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介。） |
| 5    | 频率(Frequency)                | 一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。 |
| 6    | 次序(Order)                    | 一位数字，指定 fsck 命令按照什么次序来检查文件系统。         |

| 模式     | 设备                                                         |
| :------- | :----------------------------------------------------------- |
| /dev/fd* | 软盘驱动器                                                   |
| /dev/hd* | 老系统中的 IDE(PATA)磁盘。典型的主板包含两个 IDE 连接器或者是通道，每个连接器 带有一根缆线，每根缆线上有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主设备， 第二个叫做从设备。设备名称这样安排，/dev/hda 是指第一通道上的主设备名；/dev/hdb 是第一通道上的从设备名；/dev/hdc 是第二通道上的主设备名，等等。末尾的数字表示 硬盘驱动器上的分区。例如，/dev/hda1是指系统中第一硬盘驱动器上的第一个分区，而 /dev/hda 则是指整个硬盘驱动器。 |
| /dev/lp* | 打印机                                                       |
| /dev/sd* | SCSI 磁盘。在最近的 Linux 系统中，内核把所有类似于磁盘的设备（包括 PATA/SATA 硬盘， 闪存，和 USB 存储设备，比如说可移动的音乐播放器和数码相机）看作 SCSI 磁盘。 剩下的命名系统类似于上述所描述的旧的/dev/hd*命名方案。 |
| /dev/sr* | 光盘（CD/DVD 读取器和烧写器）                                |



### 网络系统

```shell
ping - 发送 ICMP ECHO_REQUEST 数据包到网络主机
ping www.baidu.com

traceroute - 打印到一台网络主机的路由数据包
traceroute www.baidu.com

netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员
netstat -ie 使用"-ie"选项，我们能够查看系统中的网络接口第一个，叫做 eth0，是以太网接口，和第二个，叫做 lo，是内部回环网络接口，它是一个虚拟接口，系统用它来"自言自语"。
netstat -r "-r"选项会显示内核的网络路由表。

ftp - 因特网文件传输程序
ftp fileserver  
lftp - 更好的 ftp

wget - 非交互式网络下载器
wget http://linuxcommand.org/index.php

ssh - OpenSSH SSH 客户端（远程登录程序）
ssh user@IP  登陆某个终端
ssh IP 验证主机的正确性
ssh user@IP free  连接IP执行某条指令
ssh user@IP 'ls \*' > dirlist.txt  展示连接的某个用户目录下的所有信息
ssh -X user@IP 远端系统中 运行 xload 程序，但是要在我们的本地系统中看到这个程序的图形化输出。在某些系统中，你可能需要 使用 “－Y” 选项，而不是 “－X” 选项来完成这个操作。

scp 和 sftp
scp user@IP:/something .  复制远程主机下的something到本地当前目录
scp something user@IP:~/  复制本地something到远程user目录下
sftp root@192.168.99.120 

网络协议概念:
  IP (Internet Protocol) address
  IP (网络协议)地址
  Host and domain name
  主机和域名
  URI (Uniform Resource Identifier)
  URI（统一资源标识符）
  

```

ftp 一些指令展示

| 命令                             | 意思                                                         |
| :------------------------------- | :----------------------------------------------------------- |
| ftp fileserver                   | 唤醒 ftp 程序，让它连接到 FTP 服务器，fileserver。           |
| anonymous                        | 登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码， 其它一些则会要求一个邮件地址形式的密码。如果是这种情况，试着输入 “user@example.com”。 |
| cd pub/cd_images/Ubuntu-8.04     | 跳转到远端系统中，要下载文件所在的目录下， 注意在大多数匿名的 FTP 服务器中，支持公共下载的文件都能在目录 pub 下找到 |
| ls                               | 列出远端系统中的目录。                                       |
| lcd Desktop                      | 跳转到本地系统中的 ~/Desktop 目录下。在实例中，ftp 程序在工作目录 ~ 下被唤醒。 这个命令把工作目录改为 ~/Desktop |
| get ubuntu-8.04-desktop-i386.iso | 告诉远端系统传送文件到本地。因为本地系统的工作目录 已经更改到了 ~/Desktop，所以文件会被下载到此目录。 |
| bye                              | 退出远端服务器，结束 ftp 程序会话。也可以使用命令 quit 和 exit。 |

### 查找文件

```shell
locate – 通过名字来查找文件
locate bin/zip
locate zip | grep bin

find – 在一个目录层次结构中搜索文件
find . 查询当前目录下所有的信息
find . -name magic.txt  查询当前目录下是否存在名称叫magic.txt的文件
find . | wc -l 统计当前目录下的文件总数 wc -l 统计行
find . -type d | wc -l 查询统计当前目录下文件夹的数量
find . -type f | wc -l 统计文件类型为文件的数量
find . -type f -name "*.JPG" -size +1M | wc -l 统计jpg格式大于1M的文件
find . \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)  查询文件类型是f权限不是0600或者类型是d权限不是0700的所有东西
find . -print 等价于find .
find ~ -type f -name '*.BAK' -delete 删除.BAK的文件
find ~ -type f -name '*.BAK' -print  等价于 find ~ -type f -and -name '*.BAK' -and -print
用户定义的行为
	-exec command {} ;
	-exec rm '{}' ';'
	find ~ -type f -name 'foo*' -ok ls -l '{}' ';'
	find ~ -type f -name 'foo*' -exec ls -l '{}' +

xargs – 从标准输入生成和执行命令行
find ~ -type f -name 'magic*' -print | xargs ls -l 
find 命令提供的 -print0 行为， 则会产生由 null 字符分离的输出，并且 xargs 命令有一个 –null 选项，这个选项会接受由 null 字符 分离的输入。
find ~ -iname ''*.jpg' -print0 xargs –null ls -l

touch – 更改文件时间

stat – 显示文件或文件系统状态

eg:
# mkdir -p playground/dir-{00{1..9},0{10..99},100}
# touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
# find playground -type f -name 'file-A'
# find playground -type f -name 'file-A' | wc -l
# touch playground/timestamp
# stat playground/timestamp
# find playground -type f -name 'file-B' -exec touch '{}' ';'
# find playground -type f -newer playground/timestamp
# find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
# find playground \( -type f -not -perm 0600 -exec chmod 0600 '{}' ';' \) -or \( -type d -not -perm 0711 -exec chmod 0700 '{}' ';' \)

```

find文件类型

| 文件类型 | 描述             |
| :------- | :--------------- |
| b        | 块特殊设备文件   |
| c        | 字符特殊设备文件 |
| d        | 目录             |
| f        | 普通文件         |
| l        | 符号链接         |

find 大小单位

| 字符 | 单位                                           |
| :--- | :--------------------------------------------- |
| b    | 512 个字节块。如果没有指定单位，则这是默认值。 |
| c    | 字节                                           |
| w    | 两个字节的字                                   |
| k    | 千字节(1024个字节单位)                         |
| M    | 兆字节(1048576个字节单位)                      |
| G    | 千兆字节(1073741824个字节单位)                 |

find测试条件

| 测试条件       | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| -cmin n        | 匹配内容或属性最后修改时间正好在 n 分钟之前的文件或目录。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。 |
| -cnewer file   | 匹配内容或属性最后修改时间晚于 file 的文件或目录。           |
| -ctime n       | 匹配内容和属性最后修改时间在 n*24小时之前的文件和目录。      |
| -empty         | 匹配空文件和目录。                                           |
| -group name    | 匹配属于一个组的文件或目录。组可以用组名或组 ID 来表示。     |
| -iname pattern | 就像-name 测试条件，但是不区分大小写。                       |
| -inum n        | 匹配 inode 号是 n的文件。这对于找到某个特殊 inode 的所有硬链接很有帮助。 |
| -mmin n        | 匹配内容被修改于 n 分钟之前的文件或目录。                    |
| -mtime n       | 匹配的文件或目录的内容被修改于 n*24小时之前。                |
| -name pattern  | 用指定的通配符模式匹配的文件和目录。                         |
| -newer file    | 匹配内容晚于指定的文件的文件和目录。这在编写执行备份的 shell 脚本的时候很有帮。 每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来判断哪些文件自从上一次更新之后被更改了。 |
| -nouser        | 匹配不属于一个有效用户的文件和目录。这可以用来查找 属于被删除的帐户的文件或监测攻击行为。 |
| -nogroup       | 匹配不属于一个有效的组的文件和目录。                         |
| -perm mode     | 匹配权限已经设置为指定的 mode的文件或目录。mode 可以用 八进制或符号表示法。 |
| -samefile name | 类似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。 |
| -size n        | 匹配大小为 n 的文件                                          |
| -type c        | 匹配文件类型是 c 的文件。                                    |
| -user name     | 匹配属于某个用户的文件或目录。这个用户可以通过用户名或用户 ID 来表示。 |

find命令的逻辑操作符

| 操作符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| -and   | 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。 |
| -or    | 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。    |
| -not   | 若操作符后面的测试条件是假，则匹配。可以简写为一个感叹号（!）。 |
| ()     | 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，find 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。 |

find AND/OR逻辑 

| expr1 的结果 | 操作符 | expr2 is... |
| ------------ | ------ | ----------- |
| 真           | -and   | 总要执行    |
| 假           | -and   | 从不执行    |
| 真           | -or    | 从不执行    |
| 假           | -or    | 总要执行    |

*几个预定义的 find 命令操作*

| 操作    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| -delete | 删除当前匹配的文件。                                         |
| -ls     | 对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。 |
| -print  | 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。 |
| -quit   | 一旦找到一个匹配，退出。                                     |

| 测试／行为    | 只有...的时候，才被执行                                |
| ------------- | ------------------------------------------------------ |
| -print        | 只有 -type f and -name '*.BAK'为真的时候               |
| -name ‘*.BAK’ | 只有 -type f 为真的时候                                |
| -type f       | 总是被执行，因为它是与 -and 关系中的第一个测试／行为。 |

*find 命令选项*

| 选项             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| -depth           | 指示 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。 |
| -maxdepth levels | 当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数 |
| -mindepth levels | 在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。 |
| -mount           | 指示 find 程序不要搜索挂载到其它文件系统上的目录。           |
| -noleaf          | 指示 find 程序不要基于自己在搜索 Unix 的文件系统的假设，来优化它的搜索。 在搜索DOS/Windows 文件系统和CD/ROMS的时候，我们需要这个选项 |





























